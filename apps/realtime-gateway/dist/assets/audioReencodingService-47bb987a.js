function w(o){const c=o.filter(n=>n.size>0);if(c.length===0)throw new Error("All slices are empty");const e=c[0].type||"audio/webm;codecs=opus";return new Blob(c,{type:e})}async function b(o){if(o.length===0)throw new Error("No slices to re-encode");if(o.length===1)return o[0];const c=Date.now();console.log(`[AudioReencoding] Processing ${o.length} slices`);try{const e=w(o);console.log(`[AudioReencoding] Trying direct concatenation fast-path: ${(e.size/1024/1024).toFixed(2)}MB`);const n=new AudioContext,r=await e.arrayBuffer(),i=await n.decodeAudioData(r);await n.close();const t=Date.now()-c;return console.log(`[AudioReencoding] ✓ Direct concatenation validated: ${i.duration.toFixed(2)}s in ${t}ms`),e}catch(e){console.warn("[AudioReencoding] Direct concatenation validation failed, falling back to re-encode:",e)}console.log(`[AudioReencoding] Starting fallback re-encoding of ${o.length} slices`);try{const e=new AudioContext,n=[];for(let a=0;a<o.length;a++){const s=await o[a].arrayBuffer();try{const u=await e.decodeAudioData(s);n.push(u),console.log(`[AudioReencoding] ✓ Decoded slice ${a+1}/${o.length}: ${u.duration.toFixed(2)}s`)}catch(u){console.error(`[AudioReencoding] ✗ Failed to decode slice ${a+1}/${o.length}:`,u)}}if(n.length===0)throw new Error("No valid audio data could be decoded from any slice");console.log(`[AudioReencoding] Successfully decoded ${n.length}/${o.length} slices`);const r=n[0].sampleRate,i=n[0].numberOfChannels,t=n.reduce((a,s)=>a+s.length,0);console.log(`[AudioReencoding] Concatenating ${n.length} buffers: ${t} samples, ${r}Hz, ${i} channels`);const l=e.createBuffer(i,t,r);let f=0;for(const a of n){for(let s=0;s<i;s++){const u=a.getChannelData(s);l.getChannelData(s).set(u,f)}f+=a.length}const d=l.duration;console.log(`[AudioReencoding] Combined buffer duration: ${d.toFixed(2)}s`);const g=await m(l,e);await e.close();const h=Date.now()-c;return console.log(`[AudioReencoding] Fallback re-encoding complete: ${(g.size/1024/1024).toFixed(2)}MB in ${h}ms`),g}catch(e){throw console.error("[AudioReencoding] Re-encoding failed:",e),e}}async function m(o,c){return new Promise((e,n)=>{const r=c.createBufferSource();r.buffer=o;const i=c.createMediaStreamDestination();r.connect(i);const t=new MediaRecorder(i.stream,{mimeType:"audio/webm;codecs=opus",audioBitsPerSecond:128e3}),l=[];let f;t.ondataavailable=d=>{d.data.size>0&&l.push(d.data)},t.onstop=()=>{const d=new Blob(l,{type:"audio/webm"}),g=Date.now()-f;console.log(`[AudioReencoding] MediaRecorder captured ${l.length} chunks in ${g}ms`),e(d)},t.onerror=d=>{console.error("[AudioReencoding] MediaRecorder error:",d),n(new Error("MediaRecorder encoding failed"))},t.start(),f=Date.now(),r.start(0),r.onended=()=>{setTimeout(()=>{t.state!=="inactive"&&t.stop()},100)}})}export{b as reencodeAudioSlices};
